<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯çˆ±åŠ¨ç‰©æ¶ˆæ¶ˆä¹</title>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-color: #FFE6F2;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #FF6B9E;
        }
        
        h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .game-container {
            position: relative;
            background-color: #FFFFFF;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            width: 400px;
            margin-bottom: 20px;
        }

        .score, .moves, .time {
            background-color: #FFB6D9;
            padding: 10px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2em;
            width: 120px;
            text-align: center;
            color: #FFF;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-gap: 5px;
            background-color: #FFECF5;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
        }

        .tile {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #FFFFFF;
            border-radius: 10px;
            font-size: 30px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tile:hover {
            transform: scale(1.1);
        }

        .tile.selected {
            border-color: #FF6B9E;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 158, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 107, 158, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 158, 0); }
        }

        .tile.matched {
            animation: matched 0.5s forwards;
        }

        @keyframes matched {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        button {
            background-color: #FF6B9E;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background-color: #FF4D88;
            transform: translateY(-3px);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #FFFFFF;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal h2 {
            color: #FF6B9E;
            margin-top: 0;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #FFC0D5;
            animation: confetti 5s ease-in-out infinite;
        }

        @keyframes confetti {
            0% { transform: translateY(0) rotate(0); opacity: 1; }
            100% { transform: translateY(1000px) rotate(720deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <h1>å¯çˆ±åŠ¨ç‰©æ¶ˆæ¶ˆä¹</h1>
    
    <div class="game-container">
        <div class="info-panel">
            <div class="score">åˆ†æ•°: <span id="score">0</span></div>
            <div class="moves">æ­¥æ•°: <span id="moves">0</span></div>
            <div class="time">æ—¶é—´: <span id="time">60</span>ç§’</div>
        </div>
        
        <div class="game-board" id="board"></div>
        
        <div class="controls">
            <button id="reset-btn">é‡æ–°å¼€å§‹</button>
            <button id="hint-btn">æç¤º</button>
        </div>
    </div>
    
    <div class="modal" id="game-over">
        <div class="modal-content">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p>ä½ çš„æœ€ç»ˆå¾—åˆ†æ˜¯: <span id="final-score">0</span></p>
            <button id="play-again">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const config = {
            boardSize: 8,              // æ¸¸æˆé¢æ¿çš„å¤§å° (8x8)
            tileTypes: ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ¼', 'ğŸ¨'],  // å¯çˆ±åŠ¨ç‰©è¡¨æƒ…
            matchMin: 3,               // è‡³å°‘éœ€è¦åŒ¹é…çš„æ•°é‡
            initialTime: 60,           // åˆå§‹æ¸¸æˆæ—¶é—´(ç§’)
            pointsPerTile: 10,         // æ¯æ¶ˆé™¤ä¸€ä¸ªæ–¹å—å¾—åˆ†
            bonusPoints: 5,            // è¶…è¿‡3ä¸ªçš„é¢å¤–åˆ†æ•°
            hintCooldown: 10           // æç¤ºå†·å´æ—¶é—´(ç§’)
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            board: [],
            selectedTile: null,
            score: 0,
            moves: 0,
            timeLeft: config.initialTime,
            gameOver: false,
            hintAvailable: true,
            timer: null
        };

        // DOM å…ƒç´ 
        const boardElement = document.getElementById('board');
        const scoreElement = document.getElementById('score');
        const movesElement = document.getElementById('moves');
        const timeElement = document.getElementById('time');
        const resetButton = document.getElementById('reset-btn');
        const hintButton = document.getElementById('hint-btn');
        const gameOverModal = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const playAgainButton = document.getElementById('play-again');

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // åˆ›å»ºæ¸¸æˆæ¿
            createBoard();
            
            // å¡«å……åˆå§‹æ‹¼å›¾
            fillBoard();
            
            // æ£€æŸ¥å¹¶å¤„ç†åˆå§‹åŒ¹é…
            resolveMatches();
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.score = 0;
            gameState.moves = 0;
            gameState.timeLeft = config.initialTime;
            gameState.gameOver = false;
            gameState.hintAvailable = true;
            
            // æ›´æ–°UI
            updateUI();
            
            // å¯åŠ¨æ¸¸æˆè®¡æ—¶å™¨
            startTimer();
        }

        // åˆ›å»ºæ¸¸æˆæ¿
        function createBoard() {
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${config.boardSize}, 1fr)`;
            
            gameState.board = [];
            
            for (let row = 0; row < config.boardSize; row++) {
                gameState.board[row] = [];
                
                for (let col = 0; col < config.boardSize; col++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    tile.addEventListener('click', () => tileClick(row, col));
                    
                    boardElement.appendChild(tile);
                    gameState.board[row][col] = null;
                }
            }
        }

        // å¡«å……æ¸¸æˆæ¿
        function fillBoard() {
            for (let row = 0; row < config.boardSize; row++) {
                for (let col = 0; col < config.boardSize; col++) {
                    if (gameState.board[row][col] === null) {
                        let tileType;
                        // é¿å…åˆ›å»ºåˆå§‹åŒ¹é…
                        do {
                            tileType = getRandomTileType();
                        } while (
                            (row >= 2 && 
                             gameState.board[row-1][col] === tileType && 
                             gameState.board[row-2][col] === tileType) ||
                            (col >= 2 && 
                             gameState.board[row][col-1] === tileType && 
                             gameState.board[row][col-2] === tileType)
                        );
                        
                        gameState.board[row][col] = tileType;
                        updateTileDisplay(row, col);
                    }
                }
            }
        }

        // è·å–éšæœºå›¾å—ç±»å‹
        function getRandomTileType() {
            const randomIndex = Math.floor(Math.random() * config.tileTypes.length);
            return config.tileTypes[randomIndex];
        }

        // æ›´æ–°å›¾å—æ˜¾ç¤º
        function updateTileDisplay(row, col) {
            const tileElement = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
            tileElement.textContent = gameState.board[row][col];
        }

        // å›¾å—ç‚¹å‡»äº‹ä»¶
        function tileClick(row, col) {
            if (gameState.gameOver) return;
            
            const clickedTile = { row, col };
            
            // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„å›¾å—ï¼Œé€‰ä¸­å½“å‰å›¾å—
            if (gameState.selectedTile === null) {
                selectTile(clickedTile);
                return;
            }
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯å·²é€‰ä¸­çš„å›¾å—ï¼Œå–æ¶ˆé€‰æ‹©
            if (gameState.selectedTile.row === row && gameState.selectedTile.col === col) {
                deselectTile();
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦ç›¸é‚»
            if (areAdjacent(gameState.selectedTile, clickedTile)) {
                // äº¤æ¢å›¾å—
                swapTiles(gameState.selectedTile, clickedTile);
                gameState.moves++;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…
                const hasMatches = checkForMatches();
                
                if (!hasMatches) {
                    // æ²¡æœ‰åŒ¹é…ï¼Œäº¤æ¢å›æ¥
                    setTimeout(() => {
                        swapTiles(clickedTile, gameState.selectedTile);
                        deselectTile();
                    }, 500);
                } else {
                    // æœ‰åŒ¹é…ï¼Œå¤„ç†åŒ¹é…
                    resolveMatches();
                    deselectTile();
                }
                
                updateUI();
            } else {
                // ä¸ç›¸é‚»ï¼Œé€‰æ‹©æ–°çš„å›¾å—
                deselectTile();
                selectTile(clickedTile);
            }
        }

        // é€‰æ‹©å›¾å—
        function selectTile(tile) {
            gameState.selectedTile = tile;
            const tileElement = document.querySelector(`.tile[data-row="${tile.row}"][data-col="${tile.col}"]`);
            tileElement.classList.add('selected');
        }

        // å–æ¶ˆé€‰æ‹©å›¾å—
        function deselectTile() {
            if (gameState.selectedTile) {
                const tileElement = document.querySelector(`.tile[data-row="${gameState.selectedTile.row}"][data-col="${gameState.selectedTile.col}"]`);
                tileElement.classList.remove('selected');
                gameState.selectedTile = null;
            }
        }

        // æ£€æŸ¥ä¸¤ä¸ªå›¾å—æ˜¯å¦ç›¸é‚»
        function areAdjacent(tile1, tile2) {
            const rowDiff = Math.abs(tile1.row - tile2.row);
            const colDiff = Math.abs(tile1.col - tile2.col);
            
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }

        // äº¤æ¢ä¸¤ä¸ªå›¾å—
        function swapTiles(tile1, tile2) {
            const temp = gameState.board[tile1.row][tile1.col];
            gameState.board[tile1.row][tile1.col] = gameState.board[tile2.row][tile2.col];
            gameState.board[tile2.row][tile2.col] = temp;
            
            updateTileDisplay(tile1.row, tile1.col);
            updateTileDisplay(tile2.row, tile2.col);
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…
        function checkForMatches() {
            const horizontalMatches = checkHorizontalMatches();
            const verticalMatches = checkVerticalMatches();
            
            return horizontalMatches.length > 0 || verticalMatches.length > 0;
        }

        // æ£€æŸ¥æ°´å¹³åŒ¹é…
        function checkHorizontalMatches() {
            const matches = [];
            
            for (let row = 0; row < config.boardSize; row++) {
                let currentType = null;
                let matchLength = 1;
                
                for (let col = 0; col < config.boardSize; col++) {
                    const tileType = gameState.board[row][col];
                    
                    if (tileType === currentType) {
                        matchLength++;
                    } else {
                        if (matchLength >= config.matchMin) {
                            // æ‰¾åˆ°åŒ¹é…
                            for (let i = col - matchLength; i < col; i++) {
                                matches.push({ row, col: i });
                            }
                        }
                        
                        currentType = tileType;
                        matchLength = 1;
                    }
                }
                
                // æ£€æŸ¥è¡Œæœ«å°¾çš„åŒ¹é…
                if (matchLength >= config.matchMin) {
                    for (let i = config.boardSize - matchLength; i < config.boardSize; i++) {
                        matches.push({ row, col: i });
                    }
                }
            }
            
            return matches;
        }

        // æ£€æŸ¥å‚ç›´åŒ¹é…
        function checkVerticalMatches() {
            const matches = [];
            
            for (let col = 0; col < config.boardSize; col++) {
                let currentType = null;
                let matchLength = 1;
                
                for (let row = 0; row < config.boardSize; row++) {
                    const tileType = gameState.board[row][col];
                    
                    if (tileType === currentType) {
                        matchLength++;
                    } else {
                        if (matchLength >= config.matchMin) {
                            // æ‰¾åˆ°åŒ¹é…
                            for (let i = row - matchLength; i < row; i++) {
                                matches.push({ row: i, col });
                            }
                        }
                        
                        currentType = tileType;
                        matchLength = 1;
                    }
                }
                
                // æ£€æŸ¥åˆ—æœ«å°¾çš„åŒ¹é…
                if (matchLength >= config.matchMin) {
                    for (let i = config.boardSize - matchLength; i < config.boardSize; i++) {
                        matches.push({ row: i, col });
                    }
                }
            }
            
            return matches;
        }

        // å¤„ç†åŒ¹é…
        function resolveMatches() {
            const horizontalMatches = checkHorizontalMatches();
            const verticalMatches = checkVerticalMatches();
            
            const allMatches = [...horizontalMatches, ...verticalMatches];
            
            // å»é‡
            const uniqueMatches = [];
            const matchSet = new Set();
            
            for (const match of allMatches) {
                const key = `${match.row},${match.col}`;
                if (!matchSet.has(key)) {
                    matchSet.add(key);
                    uniqueMatches.push(match);
                }
            }
            
            if (uniqueMatches.length === 0) return false;
            
            // è®¡ç®—åˆ†æ•°
            const basePoints = uniqueMatches.length * config.pointsPerTile;
            const bonusPoints = (uniqueMatches.length - config.matchMin) * config.bonusPoints;
            gameState.score += basePoints + bonusPoints;
            
            // åŠ¨ç”»æ•ˆæœ
            for (const match of uniqueMatches) {
                const tileElement = document.querySelector(`.tile[data-row="${match.row}"][data-col="${match.col}"]`);
                tileElement.classList.add('matched');
                
                // ç§»é™¤åŒ¹é…çš„å›¾å—
                setTimeout(() => {
                    gameState.board[match.row][match.col] = null;
                    tileElement.classList.remove('matched');
                    tileElement.textContent = '';
                }, 500);
            }
            
            // ç§»é™¤åå¡«å……æ–°å›¾å—
            setTimeout(() => {
                // ä¸‹è½ç°æœ‰å›¾å—
                dropTiles();
                
                // å¡«å……æ–°å›¾å—
                fillBoard();
                
                // å†æ¬¡æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„åŒ¹é…
                if (checkForMatches()) {
                    setTimeout(() => {
                        resolveMatches();
                    }, 500);
                }
                
                updateUI();
            }, 600);
            
            return true;
        }

        // ä¸‹è½å›¾å—
        function dropTiles() {
            for (let col = 0; col < config.boardSize; col++) {
                let emptyRow = -1;
                
                // ä»åº•éƒ¨å‘ä¸Šæ£€æŸ¥
                for (let row = config.boardSize - 1; row >= 0; row--) {
                    if (gameState.board[row][col] === null) {
                        if (emptyRow === -1) emptyRow = row;
                    } else if (emptyRow !== -1) {
                        // ç§»åŠ¨å›¾å—åˆ°ç©ºä½ç½®
                        gameState.board[emptyRow][col] = gameState.board[row][col];
                        gameState.board[row][col] = null;
                        
                        updateTileDisplay(emptyRow, col);
                        document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`).textContent = '';
                        
                        // æ›´æ–°ç©ºä½ç½®
                        emptyRow--;
                    }
                }
            }
        }

        // æ›´æ–°UI
        function updateUI() {
            scoreElement.textContent = gameState.score;
            movesElement.textContent = gameState.moves;
            timeElement.textContent = gameState.timeLeft;
        }

        // å¯åŠ¨è®¡æ—¶å™¨
        function startTimer() {
            if (gameState.timer) clearInterval(gameState.timer);
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                timeElement.textContent = gameState.timeLeft;
                
                if (gameState.timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            clearInterval(gameState.timer);
            gameState.gameOver = true;
            
            finalScoreElement.textContent = gameState.score;
            gameOverModal.style.display = 'flex';
            
            // åˆ›å»ºå½©è‰²çº¸å±‘æ•ˆæœ
            createConfetti();
        }

        // åˆ›å»ºå½©è‰²çº¸å±‘æ•ˆæœ
        function createConfetti() {
            const colors = ['#FF6B9E', '#FFB6D9', '#FFECF5', '#FF4D88', '#FFC0D5'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.top = `-20px`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = `${5 + Math.random() * 10}px`;
                confetti.style.height = `${5 + Math.random() * 10}px`;
                confetti.style.animationDelay = `${Math.random() * 5}s`;
                confetti.style.animationDuration = `${3 + Math.random() * 5}s`;
                
                document.body.appendChild(confetti);
                
                // ä¸€æ®µæ—¶é—´åç§»é™¤çº¸å±‘
                setTimeout(() => {
                    confetti.remove();
                }, 8000);
            }
        }

        // æç¤ºåŠŸèƒ½
        function showHint() {
            if (!gameState.hintAvailable || gameState.gameOver) return;
            
            // æŸ¥æ‰¾å¯èƒ½çš„ç§»åŠ¨
            const possibleMoves = findPossibleMoves();
            
            if (possibleMoves.length > 0) {
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                // é«˜äº®æç¤º
                const tile1 = document.querySelector(`.tile[data-row="${move.tile1.row}"][data-col="${move.tile1.col}"]`);
                const tile2 = document.querySelector(`.tile[data-row="${move.tile2.row}"][data-col="${move.tile2.col}"]`);
                
                tile1.classList.add('selected');
                tile2.classList.add('selected');
                
                setTimeout(() => {
                    tile1.classList.remove('selected');
                    tile2.classList.remove('selected');
                }, 1000);
                
                // è®¾ç½®å†·å´æ—¶é—´
                gameState.hintAvailable = false;
                hintButton.disabled = true;
                
                setTimeout(() => {
                    gameState.hintAvailable = true;
                    hintButton.disabled = false;
                }, config.hintCooldown * 1000);
            }
        }

        // æŸ¥æ‰¾å¯èƒ½çš„ç§»åŠ¨
        function findPossibleMoves() {
            const possibleMoves = [];
            
            for (let row = 0; row < config.boardSize; row++) {
                for (let col = 0; col < config.boardSize; col++) {
                    // æ£€æŸ¥å³ä¾§äº¤æ¢
                    if (col < config.boardSize - 1) {
                        // æ¨¡æ‹Ÿäº¤æ¢
                        swapTiles({ row, col }, { row, col: col + 1 });
                        
                        if (checkForMatches()) {
                            possibleMoves.push({
                                tile1: { row, col },
                                tile2: { row, col: col + 1 }
                            });
                        }
                        
                        // äº¤æ¢å›æ¥
                        swapTiles({ row, col }, { row, col: col + 1 });
                    }
                    
                    // æ£€æŸ¥ä¸‹æ–¹äº¤æ¢
                    if (row < config.boardSize - 1) {
                        // æ¨¡æ‹Ÿäº¤æ¢
                        swapTiles({ row, col }, { row: row + 1, col });
                        
                        if (checkForMatches()) {
                            possibleMoves.push({
                                tile1: { row, col },
                                tile2: { row: row + 1, col }
                            });
                        }
                        
                        // äº¤æ¢å›æ¥
                        swapTiles({ row, col }, { row: row + 1, col });
                    }
                }
            }
            
            return possibleMoves;
        }

        // äº‹ä»¶ç›‘å¬
        resetButton.addEventListener('click', () => {
            clearInterval(gameState.timer);
            initGame();
        });
        
        hintButton.addEventListener('click', showHint);
        
        playAgainButton.addEventListener('click', () => {
            gameOverModal.style.display = 'none';
            initGame();
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
